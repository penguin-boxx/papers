%! suppress = EscapeAmpersand
%! suppress = TooLargeSection
%! suppress = MissingLabel

% Preamble
\documentclass[11pt]{article}

% Packages
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{multicol}
\usepackage{proof}
\usepackage{mathtools}
\usepackage{hyperref}

\usepackage{geometry}
\geometry{top=25mm}
\geometry{bottom=35mm}
\geometry{left=20mm}
\geometry{right=20mm}

\usepackage{enumitem}
\setlist{noitemsep}

\usepackage{lineno}
\linenumbers

\newcommand{\graybox}[1]{\colorbox{lightgray}{$\displaystyle #1$}}
\newcommand{\mathframebox}[1]{\framebox{$\displaystyle #1$}}
\newcommand{\vor}{~|~}
\newcommand{\ap}{~}
\newcommand{\ctx}[1]{ctx\left(#1\right)~}
\newcommand{\step}{\rightsquigarrow}
\newcommand{\local}{\top}
\newcommand{\free}{\bot}
\newcommand{\keyword}[1]{\mathbf{#1}}
\newcommand{\identation}{\text{\hspace{2em}}}

\usepackage{listings}
\lstdefinestyle{modern}{
    basicstyle=\normalfont\ttfamily\small,     % fixed-width font, smaller size
    keywordstyle=\color{blue!80!black}\bfseries,  % strong blue keywords
    stringstyle=\color{red!70!black},      % subtle red for strings
    commentstyle=\color{green!60!black}\itshape,  % italic green comments
    numberstyle=\tiny\color{gray!50},      % small, gray line numbers
    rulecolor=\color{gray!50},            % frame color
    tabsize=4,                           % tab size of 2 spaces
    showspaces=false,                   % don't show spaces as underscores
    showstringspaces=false,             % don't highlight spaces in strings
    breaklines=false,                    % automatic line breaking
    breakatwhitespace=false,             % break lines at whitespace
    captionpos=b,                       % caption at the bottom
    escapeinside={(*@}{@*)},             % escape to LaTeX inside comments
    gobble=8,      % skip 4 characters of indentation in code lines
}
\lstdefinelanguage{colang}{
    keywords=[1]{let, var, effect, perform, data, context, fun, where, if, else, throw, try, catch, local, free, op, handle, resume, class, interface, override, init, return},
    sensitive=true,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    breaklines=false,
    tabsize=4,
    showstringspaces=false,
}
\lstdefinelanguage{rust}{
    keywords={
        as, break, const, continue, crate, else, enum, extern, false, fn, for, if, impl, in,
        let, loop, match, mod, move, mut, pub, ref, return, self, Self, static, struct, super,
        trait, true, type, unsafe, use, where, while, async, await, dyn
    },
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
}
\lstset{style=modern}

% Document
\begin{document}

    \begin{center}
        \LARGE
        Type-based escape analysis with existential lifetimes

        \small
%        Andrey Stoyan
%
%        National Research University Higher School of Economics, Saint Petersburg, Russian Federation

        Keywords: type systems, escape analysis, subtyping.
    \end{center}

    \textbf{Abstract.}
    Escape analysis is a fundamental technique in programming languages used to ensure the safety of various compiler optimizations and language features.
    To achieve high precision and efficiency, particularly in interprocedural scenarios, escape analysis can be integrated into the type system.
    However, a significant drawback of this approach is that it often necessitates complex and verbose type annotations from the programmers.

    This paper introduces a novel type-based escape analysis that incorporates a union operation on lifetimes.
    This feature enables user-provided type annotations to more accurately capture a function’s data flow, thereby making such annotations simpler and more intuitive to write.
    Additionally, our approach simplifies lifetime tracking for data types through the use of existential lifetimes.
    Finally, we present a prototype implementation of the corresponding type-checking algorithm.


    \section{Introduction}

%    Type-based escape analysis augment types with special labels commonly called lifetimes.
%    Then it checks, whether an expression in some context is allowed to be typed with a particular lifetime or not.
%    Presence of these labels in type signatures makes the analysis local

    Escape analysis is a static analysis technique used to determine whether the lifetime of an object exceeds its defining lexical scope.
    This technique is widely used by optimizing compilers to facilitate stack allocation of objects that would otherwise be allocated on the heap, thereby reducing garbage collection overhead and enhancing overall program performance~\cite{blanchet1999escape}.
    Beyond optimization, escape analysis is critical for verifying the safety of various language features.
    For example, ensuring that a first-class function does not escape its intended scope allows for the safe execution of non-local returns~\cite{akhin2021kotlin}.
    Similarly, ownership-based resource management systems frequently rely on borrowing mechanisms, which permit temporary resource access without ownership transfer within confined scopes~\cite{matsakis2014rust, lorenzen2024oxidizing}.
    The primary motivation for this work is the application of escape analysis to enforce safety in contextual polymorphism within capability-based effect systems~\cite{brachthauser2020effects, boruch2023capturing}.

    Integrating escape analysis with the type system offers several significant advantages over more conventional approaches.
    First, escape information is made explicit in function signatures, which allows interprocedural analysis to be performed as an intraprocedural process that consults the signatures of callees.
    Second, such an analysis does not generate long-distance constraints, which contributes to more precise and localized error reporting.

    Despite these advantages, relatively few programming languages have adopted escape analysis integrated directly into the type system, primarily due to the inherent rigidity or complexity of the resulting systems.
    For instance, the lifetime system in the Rust programming language requires support for variance inference, lifetime polymorphism for compound data types, and explicit lifetime constraints~\cite{matsakis2014rust}.
    Collectively, these requirements result in a model that, while flexible, presents significant challenges for both compiler implementers and end users.

    In this work, we present a type-based escape analysis that intentionally trades off some expressivity to simplify user-provided type annotations.
    Specifically, our approach incorporates union types, enabling type signatures to transparently reflect a function's data flow.
    Also, we introduce existential lifetimes to automate the handling of lifetimes within data types.

    The remainder of this paper is organized as follows.
    Section~\ref{sec:overview} provides an informal introduction to our escape analysis approach, illustrated through practical examples.
    In Section~\ref{sec:formalization}, we present a formalization of our system using a rigorous formal calculus.
    Section~\ref{sec:implementation} discusses details of our prototype implementation.
    Finally, Section~\ref{sec:related-work} compares our design with existing approaches.


    \section{Solution overview} \label{sec:overview}

    This section provides an informal overview of the type-based escape analysis technique introduced in this paper.

    We define values that are constrained to a particular scope as \textit{tracked}, and their corresponding types are designated as \textit{tracked types}.
    To distinguish between tracked and non-tracked types, each type is annotated with a label, referred to as a \textit{lifetime}.
    Syntactically, a type \lstinline[language=colang]|T| with lifetime \lstinline[language=colang]|lab| is denoted as \lstinline[language=colang]{T'lab}.
    In the case of function types, the annotation specifies the lifetime of the closure, as in \lstinline[language=colang]{(A)'lab -> B}.

    The \lstinline[language=colang]|free| lifetime label denotes non-tracked types.
    In contrast, the \lstinline[language=colang]|local| label appears in tracked types, which should be prevented from escaping their defining lexical scope.
    Specifically, values typed with \lstinline[language=colang]|local| cannot be returned from functions.
    For example, this allows the type signature of a higher-order \lstinline[language=colang]|map| function to explicitly guarantee that an argument function remains confined to the function's scope:%
    \footnote{We adopt the Haskell naming convention, where type names beginning with a lowercase letter denote type variables, which are implicitly universally quantified.}%
    \footnote{When we omit the explicit lifetime annotation, we assume the \lstinline[language=colang]|free| lifetime.}
    \begin{lstlisting}[language=colang]
        fun map(xs: List<a>, f: (a)'local -> b): List<b>
    \end{lstlisting}

    To permit a function to propagate arguments through its return value, we employ polymorphism over lifetime labels.
    This approach effectively explicitly encodes the function’s data flow within the type signature.
    For instance, the \lstinline[language=colang]|lazyMap| function does not eagerly compute a final result; rather, it yields a collection that encapsulates the computation logic.
    This behavior is modeled by assigning the same lifetime variable~\lstinline[language=colang]|l| to both the argument closure \lstinline[language=colang]|f| and the result type.
    Consequently, the type system establishes that any tracked values captured by \lstinline[language=colang]|f| may persist within the returned value:
    \begin{lstlisting}[language=colang]
        fun lazyMap(xs: LazyList<a>, f: (a)'l -> b): LazyList<b>'l

        fun printAll(file: File'local, xs: LazyList<Int>) {
            let ys: LazyList<Int>'local = lazyMap(xs, (x) => file.write(x); x)
            ys.collect() // force execution
        }
    \end{lstlisting}

    To express the capture of two or more lifetime-polymorphic values, we employ a syntax with plus that denotes the minimum of their lifetimes:
    \begin{lstlisting}[language=colang]
        fun compose(f: (b)'lf -> c, g: (a)'lg -> b): (a)'lf+lg -> c =
            (x) => f(g(x))
    \end{lstlisting}

    For the sake of simplicity, lifetime polymorphism is not supported for compound datatypes.
    Instead, the lifetime of a compound data type is derived as the minimum of the lifetimes of its constituent components; this same principle applies to closures.
    Conversely, during destructuring, the lifetimes of extracted components are approximated by the lifetime of the containing compound data type:
    \begin{lstlisting}[language=colang]
        fun makeRepository(file: File'lf, conn: Connection'lc): Repository'lf+lc =
            Repository(file, conn)

        fun registerUser(repo: Repository'local, user: User) {
            let conn: Connection'local = repo.conn
            conn.send(user)
        }
    \end{lstlisting}

    We define a subtyping relationship such that non-tracked values may be used where tracked values are expected: \lstinline[language=colang]|free <: local|.
    For simplicity, our system treats all type constructors as covariant with respect to their lifetimes.

    Following~\cite{boruch2023capturing}, we permit tracked types to instantiate polymorphic type parameters, thereby making them first-class citizens in the language.
    Bounded polymorphism is used to control when tracked types are appropriate for such instantiation.
    For example, the \lstinline[language=colang]|map| function operates on values of type \lstinline[language=colang]|a| and returns values of type \lstinline[language=colang]|b| to the caller's scope.
    Consequently, these type parameters can be safely instantiated with tracked types:%
    \footnote{We assume that \lstinline[language=colang]|Any| type serves as the top element in the type lattice.}
    \begin{lstlisting}[language=colang]
        fun map(xs: List<a>, f: (a)'local -> b): List<b>
                where a <: Any'local, b <: Any'local
    \end{lstlisting}

    When a variable is captured, an unknown lifetime associated with a type argument is approximated by the lifetime of its bound.
    Consider the most permissive type signature for the \lstinline[language=colang]|lazyMap| function, which demonstrates this principle:
    \begin{lstlisting}[language=colang]
        fun lazyMap(xs: LazyList<a>, f: (a)'lf -> b): LazyList<b>'lf+la
                where a <: Any'la, b <: Any'lb
    \end{lstlisting}


    \section{Formalization} \label{sec:formalization}

    We formalize our approach as a call-by-value calculus, denoted as $Core_{\Delta}$, which is essentially a polymorphic $\lambda$-calculus extended with data constructors, subtyping and lifetime labels.

    \subsection{Syntax and semantics of $Core_\Delta$}

    The term-level syntax of $Core_\Delta$ is presented in Figure~\ref{fig:core-syntax}.
    In this notation, the overline denotes a sequence of corresponding entities.
    Furthermore, type application and type abstraction have two groups of arguments: lifetimes and types.

    \begin{figure}
        \centering
        \[
            \begin{array}{lrl}
                \text{Variables}          &   & x, y, z, f, g                                                                                                                          \\
                \text{Data constructors}  &   & K                                                                                                                                      \\
                \text{Values} & v & \Coloneqq x \vor K \vor \Lambda \overline{l}~\overline{(\alpha <: \tau)} \ldotp v \vor K\ap\overline{\Delta}\ap \overline{\tau} \ap \overline{v} \vor \lambda \overline{x : \tau}\ldotp t
                \\
                \text{Terms} & t, u & \Coloneqq v \vor t\ap\overline{\Delta}\ap\overline{\tau} \vor t\ap \overline{t} \vor match ~ t ~\{\overline{K \ap \overline{x} \to t}\}
                \\
                \text{Evaluation context} & E & \Coloneqq \square \vor E \ap\overline{\Delta}\ap \overline{\tau} \vor E \ap \overline{t} \vor v \ap (\overline{v}, E, \overline{t})    \\
                &   & \vor K\ap\overline{\Delta}\ap\overline{\tau}\ap(\overline{v}, E, \overline{t}) \vor match\ap E\ap \{\overline{K\ap\overline{x}\to t}\}
            \end{array}
        \]
        \caption{Syntax of $Core_\Delta$.}
        \label{fig:core-syntax}
    \end{figure}

    The type-level syntax of $Core_\Delta$ is given on Figure\ \ref{fig:core-types}.
    We use $+$ operator on lifetimes in prefix position when taking the minimum of a sequence of lifetimes (e.g.\ $+\overline{\Delta}$)\footnote{Effectively, the empty list of lifetimes in the minimum denotes \lstinline[language=colang]{free} lifetime. We discuss normalized presentation later in Section\ \ref{sec:implementation}.} and in notation for specific lifetimes (e.g.\ $\Delta_1 + \Delta_2$).
    All monotypes are annotated with lifetimes, while type schemas quantify over lifetime parameters and bounded type parameters.

    %! suppress = MissingLabel
    \begin{figure}
        \[
            \begin{array}{lrl}
                \text{Type variables}     &                    & \alpha, \beta                                                                                                      \\
                \text{Type constructors}  &                    & T                                                                                                                  \\
                \text{Lifetime variables} &                    & l                                                                                                                  \\
                \text{Lifetimes}          & \Delta             & \Coloneqq l \vor local \vor free \vor +\overline{\Delta}                                                           \\
                \text{Monotypes}          & \tau, \sigma, \eta & \Coloneqq \alpha \vor T \ap \Delta \ap \overline{\tau} \vor \overline{\tau}~\Delta \to \sigma                      \\
                \text{Type schemas}       & s                  & \Coloneqq \forall \overline{l}~\overline{(\alpha <: \tau)}\ldotp \sigma                                            \\
                \text{Typing contexts}    & \Gamma             & \Coloneqq \emptyset \vor x : s, \Gamma \vor l <: \Delta, \Gamma \vor \alpha <: \tau, \Gamma                        \\
                &                    & \vor K : \forall \overline{l}\ \overline{\alpha}\ldotp \overline{\tau}\to T \ap\Delta\ap \overline{\alpha}, \Gamma
            \end{array}
        \]
        \caption{Syntax of types of $Core_\Delta$.}
        \label{fig:core-types}
    \end{figure}

    The reduction semantics of $Core_\Delta$ is presented in Figure\ \ref{fig:core-operational}.

    \begin{figure}
        \begin{gather*}
            \begin{array}{llll}
                \text{(tapp)} & (\Lambda \overline{l}~\overline{\alpha}\ldotp t)\ap \overline{\Delta} \ap \overline{\tau} & \longrightarrow & [\overline{l \to \Delta}, \overline{\alpha\to\tau}]\ap t
                \\
                \text{(app)} & (\lambda \overline{x}\ldotp t) \ap \overline{v} & \longrightarrow & [\overline{x\to v}]\ap t
                \\
                \text{(match)} & match ~K \ap\Delta\ap\overline{\tau}\ap \overline{v} ~ \{ \overline{K_i \ap \overline{x}_i \to u_i}\} & \longrightarrow & [\overline{x_k\to v}]\ap u_k, \text{ where } K = K_k
            \end{array}\\
            \hspace{-15em}\infer[\text{(step)}]{E[t]\longrightarrow E[t']}{t\longrightarrow t'}
        \end{gather*}
        \caption{Operational semantics of $Core_\Delta$.}
        \label{fig:core-operational}
    \end{figure}

    \subsection{Subtyping relation}

    \begin{figure}
        \begin{gather*}
            \mathframebox{\Gamma\vdash\Delta' <: \Delta} \\[0.5em]
            \begin{array}{cc}
                \infer[SubFree]{\Gamma\vdash free <: \Delta}{} &
                \infer[SubLocal]{\Gamma\vdash\Delta <: local}{} \\[0.5em]
                \infer[SubCtx_\Delta]{
                    \Gamma\vdash l <: \Delta
                }{
                    l <: \Delta \in \Gamma
                } &
                \infer[Sub+]{
                    \Gamma\vdash+\overline{\Delta'} <: +\overline{\Delta}
                }{
                    \forall\Delta'\in\overline{\Delta'}\ldotp\exists\Delta\in\overline{\Delta}\ldotp \Gamma\vdash\Delta' <: \Delta
                }
            \end{array}\\[1em]
            \mathframebox{\Gamma\vdash \sigma <: \tau} \\[0.5em]
            \begin{array}{cc}
                \infer[SubCtx]{\Gamma\vdash \alpha <: \tau}{\alpha <: \tau \in \Gamma} &
                \infer[SubData]{
                    \Gamma\vdash T\ap\Delta'\ap\overline{\tau} <: T\ap\Delta\ap\overline{\tau}
                }{
                    \Gamma\vdash\Delta' <: \Delta
                }
            \end{array} \\[0.5em]
            \begin{array}{cc}
                \infer[SubAny]{
                    \Gamma\vdash \tau <: Any\ap\Delta
                }{
                    \Gamma\vdash +lt_\Gamma(\tau) <: \Delta
                } &
                \infer[SubFun]{
                    \Gamma\vdash\overline{\tau'}~\Delta'\to\sigma' <: \overline{\tau}~\Delta\to\sigma
                }{
                    \overline{\Gamma\vdash\tau <: \tau'} &
                    \Gamma\vdash\Delta' <: \Delta &
                    \sigma' <: \sigma
                }
            \end{array}
        \end{gather*}
        \caption{Subtyping rules of $Core_{\Delta}$.}
        \label{fig:core-subtyping}
    \end{figure}

    The subtyping relation on lifetimes, illustrated in Figure\ \ref{fig:core-subtyping}, constitutes a bounded lattice with $local$ as the top element and $free$ as the bottom.
    Consequently, the minimum of a set of lifetimes corresponds to the least upper bound within this lattice, making it analogous to a union type operation.
    When $\Delta' <: \Delta$, we say that $\Delta'$ outlives $\Delta$.

    We define the operation $lt_\Gamma(\cdot)$ to aggregate all lifetime restrictions inherent in a type.
    This operation is formally defined as follows:
    \[
        \begin{array}{lll}
            lt_\Gamma(\alpha)                                                         & = & lt_\Gamma(\tau) \text{ if } \alpha <: \tau \in \Gamma, \emptyset \text{ otherwise}        \\
            lt_\Gamma(T\ap\Delta\ap\overline{\tau})                                   & = & \overline{lt_\Gamma(\tau)} \cup \{\Delta\}                                                \\
            lt_\Gamma(\overline{\tau}~\Delta\to\overline{\sigma})                     & = & \{\Delta\}                                                                                \\
            lt_{\Gamma}(\forall \overline{l}~\overline{(\alpha <: \tau)}\ldotp\sigma) & = & lt_{\Gamma\setminus\overline{l}\setminus\overline{\alpha}}(\sigma) \setminus \overline{l} % todo тут глубокий минус на множествах
        \end{array}
    \]
    The lifetime of a type variable is approximated by the lifetime of its bounding type, if such a bound exists.
    In some cases, we intentionally employ an empty context to exclude the influence of bounds.

    The $SubAny$ rule establishes that the type $Any'\Delta$ is a supertype of $\tau$ if and only if all constituent components of $\tau$ outlive $\Delta$.

%    Notice that negative positions are not considered.
%    A function can leak a tracked value via an argument function in two situations:
%    \begin{itemize}
%        \item Firstly, this tracked value is freshly created, and its use will be restricted to the scope of an argument function.
%        In the example, \lstinline[language=colang]{withFile} is definitely untracked:
%        \begin{lstlisting}[language=colang]
%        fun withFile(path: Path, f: (File'local) -> r): r {
%            return f(File(path))
%        }
%        \end{lstlisting}
%        \item Secondly, this tracked value is captured by a closure, but in this case, it's lifetime will already be encountered in the closure's lifetime:
%        \begin{lstlisting}[language=colang]
%        (k: (File'local) -> r) => k(file)
%            : ((File'local) -> r)'local -> r
%        \end{lstlisting}
%    \end{itemize}

    \subsection{Typing basics of $Core_\Delta$}

    \begin{figure}
        \begin{gather*}
            \mathframebox{\Gamma\vdash t : s} \\[0.5em]
            \infer[Var]{\Gamma\vdash x : s}{x : s \in \Gamma} \\
            \begin{array}{cc}
                \infer[TLam]{
                    \Gamma\vdash\Lambda\overline{l}\ap\overline{(\alpha <: \sigma)}\ldotp t : \forall\overline{l}\ap\overline{(\alpha <: \sigma)}\ldotp\tau
                }{
                    \overline{\alpha <: \sigma}, \Gamma\vdash t : \tau
                } &
                \infer[TApp]{
                    \Gamma\vdash x\ap\overline{\Delta}\ap\overline{\tau'} : [\overline{\alpha\to\tau'}]\ap[\overline{l\to\Delta}]\ap\sigma
                }{
                    x : \forall\overline{l}\ap\overline{(\alpha <: \tau)}\ldotp \sigma \in \Gamma
                    &
                    \overline{\Gamma\vdash\tau' <: [\overline{l\to\Delta}]\ap\tau}
                }
            \end{array} \\[0.5em]
            \begin{array}{cc}
                \infer[Lam]{
                    \Gamma\vdash \lambda \overline{x : \tau} \ldotp t :  \overline{\tau}~ \left(+\overline{lt_\Gamma(s)}\right) \to \sigma
                }{
                    \overline{x : \tau}, \Gamma\vdash t : \sigma
                    &
                    \Gamma\vdash_{fv(t)\setminus \overline{x}}\overline{s}
                    &
                    local \not\in lt_\emptyset(\sigma)
                } &
                \infer[App]{
                    \Gamma\vdash t \ap \overline{u} : \sigma
                } {
                    \Gamma\vdash t : \overline{\tau}~\Delta\to\sigma
                    &
                    \overline{\Gamma\vdash u : \tau'}
                    &
                    \overline{\Gamma\vdash\tau' <: \tau}
                }
            \end{array} \\[0.5em]
            \begin{array}{cc}
                \mathframebox{\Gamma\vdash_{\overline{x}}\overline{\tau}} &
                \infer[TypesOf]{\Gamma\vdash_{\overline{x}}\overline{s}}{\overline{x : s} \subset \Gamma}
            \end{array}
        \end{gather*}
        \caption{Typing basics of $Core_\Delta$.}
        \label{fig:core-functions}
    \end{figure}

    The $Lam$ rule (Figure\ \ref{fig:core-functions}) is crucial for our escape analysis as it prevents leaking of tracked values by prohibiting types with $local$ lifetime present in the return type.
    Furthermore, this rule establishes that the lifetime of a function is determined by the lifetimes of all values it captures.

    \subsection{Typing data of $Core_\Delta$} \label{subsec:typing-data}

    %! suppress = EscapeAmpersand
    \begin{figure}
        \begin{gather*}
            \mathframebox{\Gamma\vdash t : s} \\[0.5em]
            \infer[Ctor]{\Gamma\vdash K : \forall\overline{l}\ \overline{\alpha}\ldotp \overline{\tau}\to T \ap\left(+\overline{lt_\emptyset(\tau)}\right)\ap \overline{\alpha}}{K : \forall\overline{l}\ \overline{\alpha}\ldotp \overline{\tau}\to T \ap\left(+\overline{lt_\emptyset(\tau)}\right)\ap \overline{\alpha} \in \Gamma} \\[0.5em]
            \infer[Match]{
                \Gamma\vdash match ~ t ~\{ \overline{K_i\ap \overline{x_{i}} \to u_i }\}  : lub\left(\overline{elim^+_{\Delta, \overline{l'}_i}\ap(\eta_i)}\right)
            }{
                \begin{array}{cc}
                    \Gamma\vdash t : T\ap\Delta \ap\overline{\tau}
                    &
                    \Gamma\vdash K_i : \forall \overline{l}_i~\overline{\alpha}\ldotp \overline{\sigma_{i}} \to T\ap\left(+\overline{lt_\emptyset(\sigma_i)}\right)\ap\overline{\alpha}
                    \\[0.4em]
                    \overline{l_i' \text{ fresh}}
                    &
                    \overline{l_i' <: \Delta}, \overline{x_i : [\overline{\alpha\to\tau}]\ap[\overline{l_i\to l_i'}]\ap\sigma_i}, \Gamma \vdash u_i : \eta_i
                \end{array}
            }
        \end{gather*}
        \caption{Typing data of $Core_{\Delta}$.}
        \label{fig:core-data-typing}
    \end{figure}

    Analogous to functions, the lifetime of a data constructor is approximated by the minimum of the lifetimes of all its constituent data types (Figure\ \ref{fig:core-data-typing}).
    Consequently, the lifetime parameters of a data constructor do not appear explicitly in the resulting type, which makes them existential in nature.

    Work with existential lifetimes requires special care in the $Match$ rule.
    For each data constructor $K_i$ and its existential lifetimes $\overline{l}_i$ we generate fresh lifetimes $\overline{l'}_i$ and approximate their bound using the lifetime of the enclosing data structure.

    In each pattern-matching branch, it is essential to eliminate these fresh lifetimes from the resulting type, as they are not bound in the outer scope.
    The function $elim_{\Delta, \overline{l}}^p(\cdot)$ eliminates lifetimes $\overline{l}$, considering the lower bound $\Delta$ and the variance position $p$, where $p$ ranges over $+, -$ and $inv$ (with $p^{-1}$ defined as $+$ if $p = -$, $-$ if $p = +$, and $inv$ if $p = inv$):
    \[
        \begin{array}{lll}
            elim_{\Delta, \overline{l}}^p(\alpha) & = & \alpha \\
            elim_{\Delta, \overline{l}}^p(T\ap \Delta'\ap\overline{\tau}) & = & T\ap \left( elim_{\Delta, \overline{l}}^p(\Delta') \right)\ap\left( \overline{elim_{\Delta, \overline{l}}^{inv}(\tau)} \right) \\
            elim_{\Delta, \overline{l}}^p(\overline{\tau}~\Delta'\to\sigma) & = & \left( \overline{elim_{\Delta, \overline{l}}^{p^{-1}}(\tau)} \right)~\left( elim_{\Delta, \overline{l}}^p(\Delta') \right)\to elim_{\Delta, \overline{l}}^{p}(\sigma) \\
            elim_{\Delta, \overline{l}}^{p}(l') & = &
            \begin{cases}
                l'     & \text{if } l' \not\in\overline{l} \\
                \Delta & \text{if } l' \in \overline{l} \land p = + \\
                free   & \text{if } l' \in \overline{l} \land p = - \\
                \text{error}  & \text{if } l' \in \overline{l} \land p = inv
            \end{cases} \\
            elim_{\Delta, \overline{l}}^{p}(+\overline{\Delta'}) & = & +\left( \overline{elim_{\Delta, \overline{l}}^{p}(\Delta')} \right) \\
            elim_{\Delta, \overline{l}}^{p}(\Delta') & = & \Delta'
        \end{array}
    \]
    When an existential lifetime appears in an invariant position, it cannot be safely approximated by either its lower or upper bound; consequently, an error is reported.
%    Otherwise, this situation can be solved by introducing bivariant projection, but we dedicate this to the future work.

    The resulting type of the entire pattern-matching expression is computed as the least upper bound ($lub$) of the branch types, from which the existential lifetimes have been eliminated.


    \section{Implementation} \label{sec:implementation}

    We provide a prototype implementation of the type-checker, developed in Haskell\footnote{\url{https://0x0.st/K9p6.zip}}.
    The core logic of the type-checker is concise, spanning approximately two hundred lines of code.
    The implementation directly follows the formal rules described in Section~\ref{sec:formalization}, with the exception that lifetimes are represented in a normalized form:
    \begin{lstlisting}[language=Haskell]
        data Lt = LtLocal | LtMin (Set LtName)
    \end{lstlisting}
    In this representation, the empty set denotes the \lstinline[language=Haskell]{free} lifetime.

    % todo ссылка на реализацию


    \section{Related work} \label{sec:related-work}

    The Rust language supports type-based escape analysis to ensure memory safety when using references~\cite{matsakis2014rust}.
    This is achieved through a combination of lifetime polymorphism, variance inference, and lifetime constraints, which together provide significant representational power but also increase the overall complexity of the type system.
    Despite that, the minimum of lifetimes can be achieved only indirectly through an additional lifetime constraints or by making all corresponding lifetimes equal.
    In contrast, our approach provides a way to express minimum directly.

    In modal OCaml, the \texttt{local} modality serves to prevent borrowed references from escaping their defining region, ensuring safe memory use and enabling optimizations such as stack allocation~\cite{lorenzen2024oxidizing}.
    Modalities here are not first-class type constructors and are rather properties of bindings, so types with modalities cannot, for example, instantiate type variables, which limits the expressiveness further.

    Contemporary research in effect systems makes extensive use of type-based escape analysis to formally guarantee safety properties.
    Xie et al.~\cite{xie2022first} adopt higher-rank types to enforce the non-leakage of effect handlers.
    Capability-based effect systems employ type-based escape analysis to establish safety of contextual polymorphism~\cite{osvald2016gentrification, brachthauser2020effects, brachthauser2022effects}.
    Recent work in the Scala language utilizes dependent types to check escaping~\cite{boruch2023capturing}.


    \section{Conclusion}

    In this work, we proposed a type-based escape analysis technique that strategically trades a degree of flexibility for the simplicity of user-defined annotations.
    Specifically, our approach incorporates a minimum operation on lifetimes and streamlines the handling of compositional data structures by approximating their lifetimes as the minimum of the lifetimes of their constituent components.
    Furthermore, we provided a formal specification of the system alongside a prototype implementation of the type-checker.

    In future work, we intend to develop a mechanized proof of soundness and evaluate the practical implications of the trade-offs inherent in our system through application to larger-scale codebases.


    \bibliographystyle{plain}
    \bibliography{bib}

\end{document}
