%! suppress = PrimitiveStyle
%! suppress = DiscouragedUseOfDef
%! suppress = MissingLabel
%! suppress = TooLargeSection

\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
%Template version as of 6/27/2024

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\usepackage{minted}
\setminted{xleftmargin=\parindent, autogobble, escapeinside=??, numberblanklines=false, fontsize=\small}
\usepackage{hyperref}
\newcommand{\seq}{;~}
\newcommand{\ap}{~}

\begin{document}

    \title{Modern Effect Systems Overview
%    \thanks{Identify applicable funding agency here. If none, delete this.}
    }

    \author{\IEEEauthorblockN{Andrey Stoyan}
    \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
    \textit{name of organization (of Aff.)}\\
    Saint Petersburg, Russia \\
    a.stoyan@hse.ru}
    }

    % todo title
    \maketitle


    \begin{abstract}
        Effect systems allow to reason statically about program effects.
        It is essential for building reliable software and clear code abstraction boundaries.
        However, proper effect system design appear to be quite a challenging task.
        Very few mainstream programming languages adopt effect systems and those attempts are known as too complicated or unusable.

        At the same time there are a lot of recent papers proposing quite promising approaches to build flexible, safe and lightweight effect systems.
        This paper aims to give and overview of selected modern works on this topic to improve awareness of practical programming languages designers and implementors about most perspective solutions.
    \end{abstract}


    \section{Introduction to effects}

    This section gives brief introduction into computational effects without deep dive into particular effect models (approaches that give dynamic semantics to effects).
    We hope that it will be enough to provide basic intuition about computational effects and convince that static control of them is a crucial task.

    We start talking about effects from the opposite, discussing purity.

    The only observable result of a pure computation is a value.
    Function is called pure if its result is the same for the same arguments and its application is a pure computation.

    Programming with pure functions is usually considered as a good practice, because it enjoys a lot of useful properties.
    E.g.\ composition of pure functions gives pure function, code semantics appears to be clear and type systems work well providing partial specification, safety and clarity of abstraction.

    However, it is quite complicated to write and support any non-trivial program using only pure computations.
    No matter that even IO can be modeled with explicit passing \mintinline{haskell}|World| value around~\cite{io}:

    \begin{minted}{haskell}
        getList :: Int -> World -> (World, [Int])
        getList n w | n == 0 = (w, [])
                    | otherwise =
          let (w', x) = getInt w in
          fmap (x :) (getList (n - 1) w')
    \end{minted}

    The problem is that with pure functions everything should be managed explicitly by receiving some parameter and returning something as a part of the result.
    So programmer should keep everything in mind and do bookkeeping manually allover the code.
    Thus there should be a tool for managing complexity, something should take a responsibility of doing bookkeeping for programmer, sweeping unnecessary details under the carpet.

    Computational effects is such a tool.
    Effects arise from interaction of computation with a context, which is responsible for bookkeeping, while computation queries it directly without lots of ceremonies pure code is full of.
    Such a context can be a language runtime system, providing OS services, mutable memory cells, advanced control mechanisms, etc.
    Effectful operation is a construct that performs an effect.
    For example\ Haskell's monadic machinery and \mintinline{haskell}|do|-syntax allow to abstract over world passing:

    \begin{minted}{haskell}
        getList :: Int -> IO [Int]
        getList n | n == 0 = pure []
                  | otherwise = do
          x <- getInt
          fmap (x :) (getList (n - 1))
    \end{minted}

    There are approaches that allow programmers to define custom effects as a library code.
    Namely effect handlers is a promising effect model that proves itself beyond pure functional languages community~\cite{eh-mainstream}.
%    Example below demonstrates simple state effect implementation.

%    \begin{minted}{haskell}
%        data State s comp = Get (s -> comp)
%                          | Put s comp
%        data Eff effs a = Pure a
%                        | Impure (effs (Eff effs a))
%
%        handleState :: Eff (State s) a -> s -> a
%        handleState comp st = case comp of
%          Pure result -> result
%          Impure (Get k) -> handleState (k st) st
%          Impure (Put newSt k) -> handleState k newSt
%    \end{minted}

    Moreover, effect handlers separate effect signatures and implementation, making nature of effects more clear.
    Expressions can be seen as clients that either are evaluated to pure result or to request to the server (execution context, effect handler)~\cite{extensible-effects}.
    Server processes the request and resumes expression evaluation with result of the effectful operation.
    Handler defines a scope in which specific effectful operations are possible, it interprets them to pure value and effects of an enclosing scope.
    E.g.\ handler of the state effect receives a computation that is able to perform state operations and produces a computation that do not require state effect anymore:
    \begin{minted}{haskell}
        handleState :: Eff (State s :+: effs) a
                    -> s -> Eff effs (s, a)
    \end{minted}
%    So effectful operations differ from pure functions in the following ways:
%    \begin{itemize}
%        \item Effectful operation implementation may preserve some state between invocations, so previous invocations may affect next ones;
%        \item Effectful operation may take control over first-class delimited continuation of the call-site (e.g.\ to be able to feature cooperative concurrency);
%        \item Semantics of effecful operation is defined in a particular scope of an effect handler, operation may have different semantics in different scopes.
%    \end{itemize}

    Custom effects is essentially a tool for creating embedded domain specific languages (eDSL).
    For example, one could define a coroutine effect that implements specific scheduling strategy and then use it as if coroutine feature was built in a host language itself~\cite{coroutines-via-eh}.
    Essentially, a host language could only support custom effects having all other features implemented as a eDSL libraries.
    Different effect models compete in flexibility, expressiveness and ease of composing different effects together, defined separately~\cite{transformers, extensible-effects, hoe}.

    % todo link to effect handlers Handling algebraic effects

    Effects are all about implicitness on term level, that is why it can be so hard to reason about them.
    At the same time real-world programs are full of effects, that is why static control of their use is crucial as well as some degree of explicitness, e.g.\ in function signatures.
    Saying specifically, we should able to be sure that every exception is handled somewhere, every function, mutating external state, declares that explicitly.

    \begin{minted}{haskell}
        f :: Int -> Eff (State Int) Int
    \end{minted}

    Without effect system it is impossible to define clear functional abstractions in impure languages, because implementation details leak unnoticed as context interactions.


    \section{Effect systems in general}

    In this section we are going to describe basic idea under all effect systems, outline core properties to use them later to describe and compare different effect systems.
    Finally, we sketch main challenges of effect systems design and conclude with brief historical notes.

    To explain general ideas we will use informal notation based on System F, extended with needed constructs.
    These constructs will be explained along the way.

    We consider only call-by-value languages, because call-by-name languages are less wide spread and results of interest can usually be adopted to monadic setting~\cite{marriage}.
    It means that effects may arise only from function applications because values are unlifted and monads are not needed for sequencing, we are can use direct-style effects.

    Classical type systems control shape input arguments and function return result.
    Specifically, we are able to say that function maps naturals to naturals:

    \[\lambda x\ldotp x + 1 : nat\to nat\]

    However, as we discussed before, tracking only pure aspect of computations is not enough.
    We would like to track also what function goes when running, how it interacts with execution context, what effects it might perform.
    Since functions are the only unevaluated computations in call-by-value language, it is natural to carry information about effects with arrow type.
    For example, we can attach effect label to the arrow itself.
    Lately we will see different concrete solutions for syntax and semantics of effect types.
    \[\lambda x\ldotp print \ap x\seq x + 1 : nat\to^{print} nat\]

    Saying precisely, effects are tracked by the type system for each term, but only for abstraction effects present explicitly in type.
    It is so because in call-by-value language abstraction is the only way for delaying computations from being evaluated immediately.
    Such delayed computation can be passed around, potentially escaping original computational context.
    So analysis becomes dataflow-sensitive and it is much easier to track effects explicitly, providing user some control and flexibility.
    We will return to this problem in upcoming sections~\ref{sec:capabilities} and~\ref{sec:modal}.

    Let us outline main desired properties of effect systems for future accurate discussion.
    Many effect systems compromise some of them for the sake of simplicity.

    The most important property of an effect system is effect safety.
    Every effect can only be performed in a context, which supports it.
    Specifically, every exception should be caught, or generally, every effect handled.
    Safety implies that no effect should ever be forgotten by the type system: if a function may perform some effect, it should mention it in its type.

    Another important property is effect encapsulation~\cite{encapsulation} guarantee.
    I.e.\ no effects should be handled accidentally without explicit declaration.
    Imagine higher order function that throws and catches exceptions for it's internal purposes.
    Without effect system, such a function is able to catch exception from parameter function invocation, while user expects it being propagated to the call-site (nothing made him think other way).
    Effect system better prevent such situations from happening, e.g.\ by requiring some explicit signal in the signature.
    For example, the following Kotlin function will silently intercept \mintinline{kotlin}|FileException| thrown in \texttt{f}.
    \begin{minted}{kotlin}
        fun withContent(f: (String) -> Unit) =
            try {
                val content = readFile(path)
                f(content) // can throw
                deleteFile(path)
            } catch (e: FileException) {}
    \end{minted}

    Effects are inherently transitive along the edges of the dynamic call-graph, i.e.\ a function’s effects include the effects of all the functions it calls, transitively~\cite{scoped-capabilities}.
    This observation highlights the most challenging aspect of system's usability in practice.
    So an effect system should answer this challenge somehow.
    Some of possible solutions are:
    \begin{itemize}
        \item Allow to simply list effect labels in type;
        \item Make effect labels pack unordered for reusability;
        \item Make effect labels pack first-class type to support effect polymorphism for higher order functions and synonym declarations;
        \item Provide robust effect types inference.
    \end{itemize}

    Effect system should provide a way to prove external purity of a function.
    Namely, some effects are used inside and do not affect externally observable behavior, so function is pure with respect to such effects.
    At the same time, some other effects may still be observable from the outside, so function should preserve them in the signature.
    In other words, there should be a way to express negation on effects.
    For example the following function in a Koka language~\cite{koka} catches exceptions of provided computation, propagating other effects unchanged (syntax will be discussed in details later):
    \[catch : \forall \mu\ap a\ldotp (unit\to^{\{exn|\mu\}} a, exception \to^{\mu} a) \to^\mu a\]

    Finally, there should be a way to use an effectful function in more permissive context then it requires.
    It is an important property for flexibility and convenience without compromising safety.
    So there should be something like subtyping on effect types.

    Originally, first effect system was proposed to statically discover scheduling constraints in parallel programming for expressions with side-effects~\cite{first-effect-system}.
    They extended type system with effect labels and regions (which describe affected area of store).
    Later Wadler and Thiemann showed~\cite{marriage} that early effect systems like~\cite{first-effect-system} can be subsumed by programming with monads~\cite{monads}.
    We are not taking into account this brunch of research because monads proved to be not well composable solution~\cite{transformers, extensible-effects} and they are not necessarily needed to model effects in call-by-value languages.

    TODO more history % todo

    There are a lot of advanced effect systems proposed and implemented in a literature.
    However, most of them simply lack usability and flexibility~\cite{scoped-capabilities}.
    In this overview we concentrate on designs that were supposed to be practical rather that very expressive and advanced.


    \section{Row-based systems}

    Row-based effect systems represent all effects of a function with row of effect labels.
    Labels are simply names of effects (source language may allow many effect operations have the same effect name), maybe applied to type arguments.
    Row type is an unordered pack of labels.
    For example, the following function in System F, extended with row types, performs two effects, listed in type (we choose neutral syntax with braces for row types):
    \begin{multline*}
        \Lambda a\ldotp\lambda xs\ldotp map \ap (\lambda x\ldotp print\ap x\seq yield\ap x) \ap xs \\ : \forall a \ldotp list\ap a \to^{\{print, ~yield \ap a\}} list \ap unit
    \end{multline*}

    Higher order functions produce at least the same effects as argument functions do.
    To express that, row-based effect systems use row polymorphism~\cite{row-poly}.
    I.e.\ type variables can stand for row types as well and they can be spliced in other row types.
    We use vertical line to say that a row type is extended by row type variable $\mu$:
    \begin{multline*}
        printMap : \forall \mu \ap a \ap b\ldotp (a \to^\mu b) \to list \ap a \to^{\{print|\mu\}} list \ap b
    \end{multline*}

    Note that ideally every higher order function should be parametrized over effects of argument functions.
    This makes smooth migration to effect system impossible and introduces significant code syntactic pollution, complicating creation of code abstractions.

    TODO effect encapsulation % todo

    TODO effect negation % todo

    TODO subeffecting and inference % todo

    TODO drawbacks of this approach % todo

    There is a famous example of row-based effect system in Java~\cite{java} --- checked exceptions.
    Java statically verifies that all checked exceptions are caught --- programmer should either catch checked exception or declare explicitly in a method signature that he propagates it to the call-site.

    Checked exceptions is famously unliked feature of Java because they are highly under-designed and lack flexibility in lots of use cases.
    For example, exception row is an ad-hoc construct and user cannot parametrize function with exception row.
    Thus it is impossible to write higher order methods that propagate arbitrary number of checked exceptions to the call-site.

    \begin{minted}{java}
        static <A, B, E extends Throwable> List<B>
            map(List<A> xs, Func<A, B, E> f)
            throws FileNotFoundException, E {...}

        Main.<String, Void, IOException>map(xs,
            (String s) -> throw new IOException(s))
    \end{minted}

    There are methods that allow to emulate row types with other language features when they are not supported directly.
    Haskell \texttt{mtl} library\footnote{\url{https://hackage.haskell.org/package/mtl}} uses type classes, which constraints are unordered and support subtyping, to emulate row types~\cite{mtl}.
    Effect handler libraries in Haskell also use type classes to express open unions similar to row-types~\cite{alacarte}.
    Another approach is to emulate row types with intersection types~\cite{intersections}, Scala ZIO\footnote{\url{https://zio.dev/}} library can be seen as a practical example of the idea.

    % todo conclusion

    Row-based effect systems seem to be the most straight-forward approach, so new effectful languages usually choose it as a baseline.
    Row types (Koka version~\cite{koka}) surprisingly fit Hindley-Milner type inference style, sub-effecting is handled by adding additional polymorphic variables to effect rows $\{exn|\mu\}$.
    At the same time rows should describe whole needed computational context, which leads to excessive verbosity of higher order function types.
    For example, function in Koka that transforms a generator requires significant amount of ceremonies to type-check:
    \begin{minted}{haskell}
        fun reyield(
            f : (int) -> <|e> int,
            g : () -> <yield,yield|e> ()) : <yield|e> ()
          with ctl yield(x)
            yield(mask<yield> { f(x) })
            resume(())
          g()
    \end{minted}


    \section{Systems based on capabilities} \label{sec:capabilities}








    Previously we used to see effects as calls of ``special'' functions, e.g. \texttt{print}.
    We tracked such functions using row types, simply placing their names (or type applications) there.
    \[\lambda x\ldotp \underline{print}\ap x;~f\ap x + 1 : nat \to^{\{print\}} nat\]

    Now we are going to look on effects from a little bitt different point of view.
    \[\lambda x\ldotp \underline{console}.print\ap x;~f\ap x + 1 : nat \to^{\{console\}} nat\]

    \[\lambda \underline{console} \ap x \ldotp console.print\ap x;~f\ap x + 1 : \underline{console} \to nat \to nat\]

    % todo dynamic binding

    \[map = \Lambda a \ap b\ldotp \lambda f\ap xs\ldotp \ldots : \forall \ap a \ap b\ldotp \underline{(a \to b)} \to list \ap a \to list \ap b \]


    % todo Kotlin

    % todo capability-based effect systems


    \section{Modal effect types} \label{sec:modal}

    % todo modal-based effect sytems


    \section{Running example: error model}

    % todo


    \section{Conclusion}

    % todo conclusion


%    \section*{Acknowledgment}
%
%    I would like to thank Mikhail Belyaev and Denis Moskvin for discussion and lots of helpful comments.
%    Also I'm grateful to Huawei Corporation for funding this work.

    % todo acknoledgement

    %! suppress = LineBreak
    \begin{thebibliography}{00}
        \bibitem{io} Peyton Jones, Simon L., and Philip Wadler. ``Imperative functional programming.'' \textit{Proceedings of the 20th ACM SIGPLAN-SIGACT symposium on Principles of programming languages}. 1993.
        \bibitem{eh-mainstream} Chandrasekaran, Sivaramakrishnan Krishnamoorthy, et al. ``Algebraic effect handlers go mainstream (dagstuhl seminar 18172).'' \textit{Dagstuhl reports}. Vol. 8. No. 4. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2018.
        \bibitem{extensible-effects} Kiselyov, Oleg, Amr Sabry, and Cameron Swords. ``Extensible effects: an alternative to monad transformers.'' \textit{ACM SIGPLAN Notices} 48.12 (2013): 59-70.
        \bibitem{first-effect-system} Lucassen, John M., and David K. Gifford. ``Polymorphic effect systems.'' \textit{Proceedings of the 15th ACM SIGPLAN-SIGACT symposium on Principles of programming languages}. 1988.
        \bibitem{marriage} Wadler, Philip, and Peter Thiemann. ``The marriage of effects and monads.'' \textit{ACM Transactions on Computational Logic (TOCL)} 4.1 (2003): 1-32.
        \bibitem{monads} Moggi, Eugenio. \textit{Computational lambda-calculus and monads}. University of Edinburgh, Department of Computer Science, Laboratory for Foundations of Computer Science, 1988.
        \bibitem{transformers} Liang, Sheng, Paul Hudak, and Mark Jones. ``Monad transformers and modular interpreters.'' \textit{Proceedings of the 22nd ACM SIGPLAN-SIGACT symposium on Principles of programming languages}. 1995.
        \bibitem{hoe} van den Berg, Birthe, and Tom Schrijvers. ``A framework for higher-order effects \& handlers.'' \textit{Science of Computer Programming} 234 (2024): 103086.
        \bibitem{encapsulation} Lindley, Sam. ``Encapsulating effects.'' \textit{Dagstuhl Reports, Volume 8, Issue 4}. 2018.
        \bibitem{links} Hillerström, Daniel, and Sam Lindley. ``Liberating effects with rows and handlers.'' \textit{Proceedings of the 1st International Workshop on Type-Driven Development}. 2016.
        \bibitem{koka} Leijen, Daan. ``Koka: Programming with row polymorphic effect types.'' \textit{arXiv preprint arXiv:1406.2061} (2014).
        \bibitem{scoped-capabilities} Odersky, Martin, et al. ``Scoped capabilities for polymorphic effects.'' \textit{arXiv preprint arXiv:2207.03402} (2022).
        \bibitem{java} Gosling, James. \textit{The Java language specification}. Addison-Wesley Professional, 2000.
        \bibitem{mtl} Jones, Mark P. ``Functional programming with overloading and higher-order polymorphism.'' \textit{Advanced
        Functional Programming: First International Spring School on Advanced
        Functional Programming Techniques Båstad, Sweden, May 24–30, 1995
        Tutorial Text 1}. Springer Berlin Heidelberg, 1995.
        \bibitem{alacarte} Swierstra, Wouter. ``Data types à la carte.'' \textit{Journal of functional programming} 18.4 (2008): 423-436.
        \bibitem{checked-exceptions} B. Venners, B. Eckel and A. Hejlsberg, ``The Trouble with Checked Exceptions'', Aug. 2003. [Online]. Available \url{https://www.artima.com/articles/the-trouble-with-checked-exceptions}.
        \bibitem{row-poly} Gaster, Benedict R., and Mark P. Jones. \textit{A polymorphic type system for extensible records and variants}. Technical Report NOTTCS-TR-96-3, Department of Computer Science, University of Nottingham, 1996.
        \bibitem{coroutines-via-eh} Leijen, Daan. ``Structured asynchrony with algebraic effects.'' \textit{Proceedings of the 2nd ACM SIGPLAN International Workshop on Type-Driven Development}. 2017.
        \bibitem{intersections} Xie, Ningning, et al. ``Row and bounded polymorphism via disjoint polymorphism.'' \textit{34th European Conference on Object-Oriented Programming (ECOOP 2020)}. Schloss-Dagstuhl-Leibniz Zentrum für Informatik, 2020.
    \end{thebibliography}


%    \begin{abstract}
%        This document is a model and instructions for \LaTeX.
%        This and the IEEEtran.cls file define the components of your paper [title, text, heads, etc.]. *CRITICAL: Do Not Use Symbols, Special Characters, Footnotes,
%        or Math in Paper Title or Abstract.
%    \end{abstract}
%
%    \begin{IEEEkeywords}
%        component, formatting, style, styling, insert.
%    \end{IEEEkeywords}
%
%
%    \section{Introduction}
%    This document is a model and instructions for \LaTeX.
%    Please observe the conference page limits. For more information about how to become an IEEE Conference author or how to write your paper, please visit IEEE Conference Author Center website: https://conferences.ieeeauthorcenter.ieee.org/.
%
%    \subsection{Maintaining the Integrity of the Specifications}
%
%    The IEEEtran class file is used to format your paper and style the text. All margins,
%    column widths, line spaces, and text fonts are prescribed; please do not
%    alter them. You may note peculiarities. For example, the head margin
%    measures proportionately more than is customary. This measurement
%    and others are deliberate, using specifications that anticipate your paper
%    as one part of the entire proceedings, and not as an independent document.
%    Please do not revise any of the current designations.
%
%
%    \section{Prepare Your Paper Before Styling}
%    Before you begin to format your paper, first write and save the content as a
%    separate text file. Complete all content and organizational editing before
%    formatting. Please note sections \ref{AA} to \ref{FAT} below for more information on
%    proofreading, spelling and grammar.
%
%    Keep your text and graphic files separate until after the text has been
%    formatted and styled. Do not number text heads---{\LaTeX} will do that
%    for you.
%
%    \subsection{Abbreviations and Acronyms}\label{AA}
%    Define abbreviations and acronyms the first time they are used in the text,
%    even after they have been defined in the abstract. Abbreviations such as
%    IEEE, SI, MKS, CGS, ac, dc, and rms do not have to be defined. Do not use
%    abbreviations in the title or heads unless they are unavoidable.
%
%    \subsection{Units}
%    \begin{itemize}
%        \item Use either SI (MKS) or CGS as primary units. (SI units are encouraged.) English units may be used as secondary units (in parentheses). An exception would be the use of English units as identifiers in trade, such as ``3.5-inch disk drive''.
%        \item Avoid combining SI and CGS units, such as current in amperes and magnetic field in oersteds. This often leads to confusion because equations do not balance dimensionally. If you must use mixed units, clearly state the units for each quantity that you use in an equation.
%        \item Do not mix complete spellings and abbreviations of units: ``Wb/m\textsuperscript{2}'' or ``webers per square meter'', not ``webers/m\textsuperscript{2}''. Spell out units when they appear in text: ``. . . a few henries'', not ``. . . a few H''.
%        \item Use a zero before decimal points: ``0.25'', not ``.25''. Use ``cm\textsuperscript{3}'', not ``cc''.)
%    \end{itemize}
%
%    \subsection{Equations}
%    Number equations consecutively. To make your
%    equations more compact, you may use the solidus (~/~), the exp function, or
%    appropriate exponents. Italicize Roman symbols for quantities and variables,
%    but not Greek symbols. Use a long dash rather than a hyphen for a minus
%    sign. Punctuate equations with commas or periods when they are part of a
%    sentence, as in:
%    \begin{equation}
%        a+b=\gamma\label{eq}
%    \end{equation}
%
%    Be sure that the
%    symbols in your equation have been defined before or immediately following
%    the equation. Use ``\eqref{eq}'', not ``Eq.~\eqref{eq}'' or ``equation \eqref{eq}'', except at
%    the beginning of a sentence: ``Equation \eqref{eq} is . . .''
%
%    \subsection{\LaTeX-Specific Advice}
%
%    Please use ``soft'' (e.g., \verb|\eqref{Eq}|) cross references instead
%    of ``hard'' references (e.g., \verb|(1)|). That will make it possible
%    to combine sections, add equations, or change the order of figures or
%    citations without having to go through the file line by line.
%
%    Please don't use the \verb|{eqnarray}| equation environment. Use
%    \verb|{align}| or \verb|{IEEEeqnarray}| instead. The \verb|{eqnarray}|
%    environment leaves unsightly spaces around relation symbols.
%
%    Please note that the \verb|{subequations}| environment in {\LaTeX}
%    will increment the main equation counter even when there are no
%    equation numbers displayed. If you forget that, you might write an
%    article in which the equation numbers skip from (17) to (20), causing
%    the copy editors to wonder if you've discovered a new method of
%    counting.
%
%        {\BibTeX} does not work by magic. It doesn't get the bibliographic
%    data from thin air but from .bib files. If you use {\BibTeX} to produce a
%    bibliography you must send the .bib files.
%
%        {\LaTeX} can't read your mind. If you assign the same label to a
%    subsubsection and a table, you might find that Table I has been cross
%    referenced as Table IV-B3.
%
%        {\LaTeX} does not have precognitive abilities. If you put a
%    \verb|\label| command before the command that updates the counter it's
%    supposed to be using, the label will pick up the last counter to be
%    cross referenced instead. In particular, a \verb|\label| command
%    should not go before the caption of a figure or a table.
%
%    Do not use \verb|\nonumber| inside the \verb|{array}| environment. It
%    will not stop equation numbers inside \verb|{array}| (there won't be
%    any anyway) and it might stop a wanted equation number in the
%    surrounding equation.
%
%    \subsection{Some Common Mistakes}\label{SCM}
%    \begin{itemize}
%        \item The word ``data'' is plural, not singular.
%        \item The subscript for the permeability of vacuum $\mu_{0}$, and other common scientific constants, is zero with subscript formatting, not a lowercase letter ``o''.
%        \item In American English, commas, semicolons, periods, question and exclamation marks are located within quotation marks only when a complete thought or name is cited, such as a title or full quotation. When quotation marks are used, instead of a bold or italic typeface, to highlight a word or phrase, punctuation should appear outside of the quotation marks. A parenthetical phrase or statement at the end of a sentence is punctuated outside of the closing parenthesis (like this). (A parenthetical sentence is punctuated within the parentheses.)
%        \item A graph within a graph is an ``inset'', not an ``insert''. The word alternatively is preferred to the word ``alternately'' (unless you really mean something that alternates).
%        \item Do not use the word ``essentially'' to mean ``approximately'' or ``effectively''.
%        \item In your paper title, if the words ``that uses'' can accurately replace the word ``using'', capitalize the ``u''; if not, keep using lower-cased.
%        \item Be aware of the different meanings of the homophones ``affect'' and ``effect'', ``complement'' and ``compliment'', ``discreet'' and ``discrete'', ``principal'' and ``principle''.
%        \item Do not confuse ``imply'' and ``infer''.
%        \item The prefix ``non'' is not a word; it should be joined to the word it modifies, usually without a hyphen.
%        \item There is no period after the ``et'' in the Latin abbreviation ``et al.''.
%        \item The abbreviation ``i.e.'' means ``that is'', and the abbreviation ``e.g.'' means ``for example''.
%    \end{itemize}
%    An excellent style manual for science writers is \cite{b7}.
%
%    \subsection{Authors and Affiliations}\label{AAA}
%    \textbf{The class file is designed for, but not limited to, six authors.} A
%    minimum of one author is required for all conference articles. Author names
%    should be listed starting from left to right and then moving down to the
%    next line. This is the author sequence that will be used in future citations
%    and by indexing services. Names should not be listed in columns nor group by
%    affiliation. Please keep your affiliations as succinct as possible (for
%    example, do not differentiate among departments of the same organization).
%
%    \subsection{Identify the Headings}\label{ITH}
%    Headings, or heads, are organizational devices that guide the reader through
%    your paper. There are two types: component heads and text heads.
%
%    Component heads identify the different components of your paper and are not
%    topically subordinate to each other. Examples include Acknowledgments and
%    References and, for these, the correct style to use is ``Heading 5''. Use
%    ``figure caption'' for your Figure captions, and ``table head'' for your
%    table title. Run-in heads, such as ``Abstract'', will require you to apply a
%    style (in this case, italic) in addition to the style provided by the drop
%    down menu to differentiate the head from the text.
%
%    Text heads organize the topics on a relational, hierarchical basis. For
%    example, the paper title is the primary text head because all subsequent
%    material relates and elaborates on this one topic. If there are two or more
%    sub-topics, the next level head (uppercase Roman numerals) should be used
%    and, conversely, if there are not at least two sub-topics, then no subheads
%    should be introduced.
%
%    \subsection{Figures and Tables}\label{FAT}
%
%    \paragraph{Positioning Figures and Tables} Place figures and tables at the top and
%    bottom of columns. Avoid placing them in the middle of columns. Large
%    figures and tables may span across both columns. Figure captions should be
%    below the figures; table heads should appear above the tables. Insert
%    figures and tables after they are cited in the text. Use the abbreviation
%    ``Fig.~\ref{fig}'', even at the beginning of a sentence.
%
%    \begin{table}[htbp]
%        \caption{Table Type Styles}
%        \begin{center}
%            \begin{tabular}{|c|c|c|c|}
%                \hline
%                \textbf{Table} & \multicolumn{3}{|c|}{\textbf{Table Column Head}} \\
%                \cline{2-4}
%                \textbf{Head} & \textbf{\textit{Table column subhead}} & \textbf{\textit{Subhead}} & \textbf{\textit{Subhead}} \\
%                \hline
%                copy          & More table copy$^{\mathrm{a}}$         &                           &                           \\
%                \hline
%                \multicolumn{4}{l}{$^{\mathrm{a}}$Sample of a Table footnote.}
%            \end{tabular}
%            \label{tab1}
%        \end{center}
%    \end{table}
%
%    \begin{figure}[htbp]
%        \centerline{\includegraphics{fig1.png}}
%        \caption{Example of a figure caption.}
%        \label{fig}
%    \end{figure}
%
%    Figure Labels: Use 8 point Times New Roman for Figure labels. Use words
%    rather than symbols or abbreviations when writing Figure axis labels to
%    avoid confusing the reader. As an example, write the quantity
%    ``Magnetization'', or ``Magnetization, M'', not just ``M''. If including
%    units in the label, present them within parentheses. Do not label axes only
%    with units. In the example, write ``Magnetization (A/m)'' or ``Magnetization
%    \{A[m(1)]\}'', not just ``A/m''. Do not label axes with a ratio of
%    quantities and units. For example, write ``Temperature (K)'', not
%    ``Temperature/K''.
%
%    \section*{Acknowledgment}
%
%    The preferred spelling of the word ``acknowledgment'' in America is without
%    an ``e'' after the ``g''. Avoid the stilted expression ``one of us (R. B.
%    G.) thanks $\ldots$''. Instead, try ``R. B. G. thanks$\ldots$''. Put sponsor
%    acknowledgments in the unnumbered footnote on the first page.
%
%    \section*{References}
%
%    Please number citations consecutively within brackets \cite{b1}. The
%    sentence punctuation follows the bracket \cite{b2}. Refer simply to the reference
%    number, as in \cite{b3}---do not use ``Ref. \cite{b3}'' or ``reference \cite{b3}'' except at
%    the beginning of a sentence: ``Reference \cite{b3} was the first $\ldots$''
%
%    Number footnotes separately in superscripts. Place the actual footnote at
%    the bottom of the column in which it was cited. Do not put footnotes in the
%    abstract or reference list. Use letters for table footnotes.
%
%    Unless there are six authors or more give all authors' names; do not use
%    ``et al.''. Papers that have not been published, even if they have been
%    submitted for publication, should be cited as ``unpublished'' \cite{b4}. Papers
%    that have been accepted for publication should be cited as ``in press'' \cite{b5}.
%    Capitalize only the first word in a paper title, except for proper nouns and
%    element symbols.
%
%    For papers published in translation journals, please give the English
%    citation first, followed by the original foreign-language citation \cite{b6}.
%
%    \begin{thebibliography}{00}
%        \bibitem{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,'' Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.
%        \bibitem{b2} J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.
%        \bibitem{b3} I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,'' in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.
%        \bibitem{b4} K. Elissa, ``Title of paper if known,'' unpublished.
%        \bibitem{b5} R. Nicole, ``Title of paper with only first word capitalized,'' J. Name Stand. Abbrev., in press.
%        \bibitem{b6} Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,'' IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].
%        \bibitem{b7} M. Young, The Technical Writer's Handbook. Mill Valley, CA: University Science, 1989.
%        \bibitem{b8} D. P. Kingma and M. Welling, ``Auto-encoding variational Bayes,'' 2013, arXiv:1312.6114. [Online]. Available: https://arxiv.org/abs/1312.6114
%        \bibitem{b9} S. Liu, ``Wi-Fi Energy Detection Testbed (12MTC),'' 2023, gitHub repository. [Online]. Available: https://github.com/liustone99/Wi-Fi-Energy-Detection-Testbed-12MTC
%        \bibitem{b10} ``Treatment episode data set: discharges (TEDS-D): concatenated, 2006 to 2009.'' U.S. Department of Health and Human Services, Substance Abuse and Mental Health Services Administration, Office of Applied Studies, August, 2013, DOI:10.3886/ICPSR30122.v2
%        \bibitem{b11} K. Eves and J. Valasek, ``Adaptive control for singularly perturbed systems examples,'' Code Ocean, Aug. 2023. [Online]. Available: https://codeocean.com/capsule/4989235/tree
%    \end{thebibliography}
%givi
%    \vspace{12pt}
%    \color{red}
%    IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.

\end{document}
