%! suppress = PrimitiveStyle
%! suppress = DiscouragedUseOfDef
%! suppress = MissingLabel
%! suppress = TooLargeSection

\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
%Template version as of 6/27/2024

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\usepackage{minted}
\setminted{xleftmargin=\parindent, autogobble, escapeinside=??, numberblanklines=false, fontsize=\small}
\usepackage{hyperref}
\usepackage{proof}
\newcommand{\seq}{;~}
\newcommand{\ap}{~}

\begin{document}

    \title{Modern Effect Systems Overview
%    \thanks{Identify applicable funding agency here. If none, delete this.}
    }

    \author{\IEEEauthorblockN{Andrey Stoyan}
    \IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
    \textit{name of organization (of Aff.)}\\
    Saint Petersburg, Russia \\
    a.stoyan@hse.ru}
    }

    % todo title
    \maketitle


    \begin{abstract}
        Effect systems allow one to reason statically about program effects.
        It is essential for building reliable software and clear code abstraction boundaries.
        However, proper effect system design is quite a challenging task.
        Only some mainstream programming languages adopt effect systems, and those attempts are considered too complicated or unusable.

        At the same time, many recent papers propose quite promising approaches to building flexible, safe, and lightweight effect systems.
        This paper aims to overview selected modern works on this topic to improve the awareness of practical programming language designers and implementors of most perspective solutions.
    \end{abstract}


    \section{Introduction to effects}

    This section briefly introduces computational effects without a deep dive into particular effect models (approaches that give effects dynamic semantics).
    We hope it provides basic intuition about computational effects and convinces about the cruciality of static control over them.

    We start talking about effects from the opposite, discussing purity.
    The only observable result of a pure computation is a value.
    A function is called pure if its result is the same for the same arguments, and its application is a pure computation.

    Programming with pure functions is usually considered a good practice because it enjoys a lot of useful properties.
    The composition of pure functions gives pure functions, code semantics appear clear, and type systems work well, providing partial specification, safety, and clarity of abstraction.

    However, writing and supporting any non-trivial program using only pure computations is quite complicated.
    No matter that even input/output can be modeled with explicit passing \mintinline{haskell}|World| value around~\cite{peyton1993imperative}:

    \begin{minted}{haskell}
        getList :: Int -> World -> (World, [Int])
        getList n w | n == 0 = (w, [])
                    | otherwise =
          let (w', x) = getInt w in
          fmap (x :) (getList (n - 1) w')
    \end{minted}

    The problem is that with pure functions, everything should be managed explicitly by receiving some parameters and returning something.
    So, the programmer should keep everything in mind and do bookkeeping manually all over the code.
    Thus, a tool for managing complexity is necessary: something that takes responsibility for bookkeeping for programmers and sweeps unnecessary details under the carpet.

    Computational effects is such a tool.
    Effects arise from the interaction of computation with a context, which is responsible for bookkeeping, while computation queries it directly without the many ceremonies pure code is full of.
    Such a context can be a language runtime system that provides OS services, mutable memory cells, advanced control mechanisms, etc.
    An effectful operation is a construct that performs an effect.
    For example, Haskell's monadic machinery and \mintinline{haskell}|do|-syntax allow to abstract over world passing:

    \begin{minted}{haskell}
        getList :: Int -> IO [Int]
        getList n | n == 0 = pure []
                  | otherwise = do
          x <- getInt
          fmap (x :) (getList (n - 1))
    \end{minted}

    Some approaches allow programmers to define custom effects as a library code.
    Namely, effect handlers are a promising effect model that proves itself beyond pure functional languages community~\cite{plotkin2013handling, chandrasekaran2018algebraic}.
%    Example below demonstrates simple state effect implementation.

%    \begin{minted}{haskell}
%        data State s comp = Get (s -> comp)
%                          | Put s comp
%        data Eff effs a = Pure a
%                        | Impure (effs (Eff effs a))
%
%        handleState :: Eff (State s) a -> s -> a
%        handleState comp st = case comp of
%          Pure result -> result
%          Impure (Get k) -> handleState (k st) st
%          Impure (Put newSt k) -> handleState k newSt
%    \end{minted}

    Moreover, effect handlers separate effect signatures and implementation, making the effects' nature more apparent.
    Expressions can be seen as clients that either are evaluated to pure result or to request to the server (execution context, effect handler)~\cite{kiselyov2013extensible}.
    The server processes the request and resumes expression evaluation with the result of the effectful operation.
    The handler defines a scope in which specific effectful operations are possible; it interprets them to be the pure value and effects of the enclosing scope.
    For example, the handler of the state effect receives a computation that can perform state operations and produces a computation that does not require state effect anymore:
    \begin{minted}{haskell}
        handleState :: Eff (State s :+: effs) a
                    -> s -> Eff effs (s, a)
    \end{minted}
%    So effectful operations differ from pure functions in the following ways:
%    \begin{itemize}
%        \item Effectful operation implementation may preserve some state between invocations, so previous invocations may affect next ones;
%        \item Effectful operation may take control over first-class delimited continuation of the call-site (e.g.\ to be able to feature cooperative concurrency);
%        \item Semantics of effecful operation is defined in a particular scope of an effect handler, operation may have different semantics in different scopes.
%    \end{itemize}

    Custom effects are a tool for creating embedded domain-specific languages (eDSL).
    For example, one could define a coroutine effect that implements a specific scheduling strategy and then use it as if the coroutine feature were built in a the host language itself~\cite{leijen2017structured}.
    A host language could only support custom effects when all other features are implemented as eDSL libraries.
    Different effect models compete in expressiveness and ease of composing different effects together, defined separately~\cite{liang1995monad, kiselyov2013extensible, schrijvers2019monad, van2024framework}.

    Effects are all about implicitness on a term level, which is why they can be so difficult to reason about.
    At the same time, real-world programs are full of effects, so static control of their use is crucial, as well as some degree of explicitness, e.g., \ in function signatures.
    Specifically, we should be able to be sure that every exception is handled somewhere, and every function, mutating external state, declares that explicitly.

    \begin{minted}{haskell}
        f :: Int -> Eff (State Int) Int
    \end{minted}

    Without an effect system, defining clear functional abstractions in impure languages is not straightforward because implementation details leak unnoticed as context interactions.


    \section{Effect systems in general}

    In this section, we will describe the basic idea behind all effect systems and outline their core properties so we can later describe and compare different effect systems.
    Finally, we sketch the main challenges of effect systems design and conclude with brief historical notes.

    To explain general ideas, we will use informal notation based on System F, which we will extend with the needed constructs.
    We will explain these constructs along the way.

    We consider only call-by-value languages because call-by-name languages are less widespread, and results of interest can usually be adapted to monadic setting~\cite{wadler2003marriage}.
    Thus, Effects may arise only from function applications (values are unlifted), and we do not need monads for sequencing, so we can use direct-style effects.

    Classical type systems control shape input arguments and function return result.
    Specifically, we can say that function maps naturals to naturals:
    \[\lambda x\ldotp x + 1 : nat\to nat\]

    However, as discussed before, more than tracking the pure aspect of computations is required.
    We would also like to track what function goes when running, how it interacts with the execution context, and what effects it might perform.
    Since functions are the only unevaluated computations in call-by-value language, carrying information about effects with arrow type is natural.
    For example, we can attach an effect label to the arrow itself.
    We will see different concrete solutions for syntax and semantics of effect types.
    \[\lambda x\ldotp print \ap x\seq x + 1 : nat\to^{print} nat\]

    Specifically, the type system tracks effects for each term but only for abstraction effects present explicitly in type.
    This is because, in a call-by-value language, abstraction is the only way to delay computations from being evaluated immediately.
    Such delayed computation can be passed around, potentially escaping the original computational context.
    So, analysis becomes dataflow-sensitive, and it is much easier to track effects explicitly, providing users some control and flexibility.
    We will return to this problem in upcoming sections~\ref{sec:capabilities} and~\ref{sec:modal}.

    Let us outline the desired properties of effect systems for future accurate discussion.
    Many effect systems compromise some of them for the sake of simplicity.

    The most important property of an effect system is effect safety.
    Every effect can only be performed in a context that supports it.
    Specifically, every exception should be caught, or generally, every effect should be handled.
    Safety implies that the type system should never forget effects: if a function may perform some effect, it should mention it in its type.

    Another important property is the existence of effect encapsulation means~\cite{lindley2018encapsulating}.
    Imagine a higher-order function that throws and catches exceptions for its internal purposes.
    Without an effect system, such a function can catch exceptions from parameter function invocation while the user expects them to be propagated to the call site (nothing made him think the other way).
    For example, the following Scala function will silently intercept \mintinline{kotlin}|FileException| thrown in \texttt{f}.
    \begin{minted}{scala}
        def withContent(f: String => Unit) =
          try {
            val content = readFile(path)
            f(content) // may throw
            deleteFile(path)
          } catch (e: FileException) {}
    \end{minted}

    We consider two aspects of encapsulation.
    Firstly, the effect system should prevent accidental handling, i.e.,\ it should explicitly track information that particular effects will be handled, e.g.,\ in the previous example, \texttt{f} type should carry the information about expected \mintinline{scala}|FileException|.
    Secondly, there should be a way to mask implementation detail effects from being handled by the innermost handler \mintinline{scala}|mask(f(content))| (in this case, no additional type information is needed).

    Effects are inherently transitive along the edges of the dynamic call-graph, i.e., \ a function's effects include the effects of all the functions it calls transitively~\cite{odersky2022scoped}.
    This observation highlights the most challenging aspect of the system's usability.
    An effect system should answer this challenge somehow.
    Some of the possible solutions are:
    \begin{itemize}
        \item Allow to list effect labels in type;
        \item Make effect labels pack unordered for reusability;
        \item Make effect labels pack first-class type to support effect polymorphism for higher-order functions and synonym declarations;
        \item Provide robust effect types inference.
    \end{itemize}

    Effect systems should provide a way to prove the external purity of a function.
    Namely, some effects are used inside and do not affect externally observable behavior, so the function is pure concerning such effects.
    At the same time, some other effects may still be observable from the outside, so the function should preserve them in the signature.
    In other words, there should be a way to express negation on effects.
    Technically, it is similar to the first aspect of effect encapsulation discussed above.
    For example, the following function in a Koka language~\cite{leijen2014koka, leijen2017type} catches exceptions of provided computation, propagating other effects unchanged (syntax will be discussed in detail later):
    \[catch : \forall \mu\ap a\ldotp (unit\to^{\{exn|\mu\}} a, exception \to^{\mu} a) \to^\mu a\]

    Finally, there should be a way to use an effectful function in a more permissive context than it requires.
    It is an essential property for flexibility and convenience without compromising safety.
    So, there should be subtyping on effect types.


    The first effect system was proposed to statically discover scheduling constraints in parallel programming for expressions with side effects~\cite{lucassen1988polymorphic}.
    They extended the type system with effect labels and regions (which describe the affected area of the store).
    Later, Wadler and Thiemann showed~\cite{wadler2003marriage} that programming with monads~\cite{moggi1988computational} can subsume early effect systems like the one proposed by Lucassen and Gifford~\cite{lucassen1988polymorphic}.
    We are not considering this branch of research because monads proved to be not a well-composable solution~\cite{liang1995monad, kiselyov2013extensible}, and they are not necessarily needed to model effects in call-by-value languages.

    Many advanced effect systems have been proposed and implemented in the literature.
    However, most of them lack usability and flexibility~\cite{odersky2022scoped}.
    In this overview, we concentrate on designs that were supposed to be practical rather than very expressive and advanced.


    \section{Row-based systems} \label{sec:rows}

    Row-based effect systems represent all effects of a function with a row of effect labels.
    Labels are the names of effects (the source language may allow many effect operations to have the same effect name), potentially applied to type arguments.
    Row type is an unordered pack of labels.
    For example, the following function in System F, extended with row types, performs two effects listed in type (we choose neutral syntax with braces for row types):
    \begin{multline*}
        \Lambda a\ldotp\lambda xs\ldotp map \ap (\lambda x\ldotp print\ap x\seq yield\ap x) \ap xs \\ : \forall a \ldotp list\ap a \to^{\{print, ~yield \ap a\}} list \ap unit
    \end{multline*}

    Higher-order functions produce at least the same effects as argument functions do.
    Row-based effect systems use row polymorphism to express it~\cite{gaster1996polymorphic}.
    I.e., \ type variables can also stand for row types, and they can be spliced into other row types.
    We use a vertical line to extend a row type by row type variable $\mu$:
    \begin{multline*}
        printMap : \forall \mu \ap a \ap b\ldotp (a \to^\mu b) \to list \ap a \to^{\{print|\mu\}} list \ap b
    \end{multline*}

    Ideally, every higher-order function should be parametrized over the effects of argument functions, which makes smooth migration to the effect system impossible and introduces significant code syntactic pollution, complicating the creation of code abstractions.


    Checked exceptions in Java~\cite{gosling2000java} is a famous example of a row-based effect system.
    Java statically verifies that all checked exceptions are caught.
    The programmer should either catch a checked exception or declare explicitly in a method signature that he propagates it to the call site.

    Checked exceptions are a famously unliked feature of Java because they are highly under-designed and lack flexibility in lots of use cases~\cite{checked-exceptions}.
    For example, the exception row is an ad hoc construct, and the user cannot parametrize the function with it.
    Thus, writing higher-order methods that propagate an arbitrary number of checked exceptions to the call site is impossible.

    \begin{minted}{java}
        static <A, B, E extends Throwable> List<B>
            map(List<A> xs, Func<A, B, E> f)
            throws FileNotFoundException, E {...}

        Main.<String, Void, IOException>map(xs,
            (String s) -> throw new IOException(s))
    \end{minted}


    Many research languages are implementing row-based effect systems.
    Some of them are overcomplicated in supporting external purity proofs and effect encapsulation.
    For example, they use presence annotations on effect labels and presence polymorphism~\cite{hillerstrom2016liberating}.
    We will use the effect system of the Koka language for illustrative purposes because it is simple yet powerful enough~\cite{leijen2014koka, leijen2017type}.

    Koka distinguishes duplicated effect labels in rows $\{l,l\}\neq \{l\}$, following the idea of scoped labels designed for record types~\cite{leijen2005extensible}.
    It allows Koka to achieve several goals at once.
    In particular, effect elimination forms are straightforward: we discard \texttt{exn} in final effect \texttt{e} (Koka uses angle brackets after the function arrow for row types).
    \begin{minted}{haskell}
        fun catch(f : () -> <exn|e> a,
                  h : err -> <|e> a) : <|e> a
    \end{minted}

    TODO external purity % todo

    Koka will prevent accidental handling by inferring the proper type that informs programmer that a particular effect will be handled.
    At the same time, Koka provides \texttt{mask} operation to hide a particular effect from the innermost handler and, therefore, encapsulate this effect.
    The type of \texttt{mask} is \texttt{(() -> <l|e> a) -> () -> <l,l|e> a}.
    For example, the following function that transforms a generator hides handling of \texttt{yield} effect from function \texttt{f} (however, it is impossible to hide second \texttt{yield} from \texttt{g}):
    \begin{minted}{haskell}
        fun reyield(
            f : (int) -> <|e> int,
            g : () -> <yield,yield|e> ()
        ) : <yield|e> ()
          with ctl yield(x) // (1)
            yield(mask<yield> { f(x) })
            resume(())
          g() // yield dispatches to (1)
    \end{minted}


    Some methods allow the emulation of row types with other language features when not directly supported.
    Haskell \texttt{mtl} library\footnote{\url{https://hackage.haskell.org/package/mtl}} uses type class constraints to list effects~\cite{jones1995functional}.
    Since constraints are unordered and support subtyping, we can see them as ad-hoc row types.
    Effect handler libraries in Haskell also use type classes to express open unions similar to row-types~\cite{swierstra2008data}.
    Another approach is to emulate row types with intersection types~\cite{xie2020row}, Scala ZIO\footnote{\url{https://zio.dev/}} library can be seen as a practical example of the idea.

    Row-based effect systems are the most straightforward approach, so new effectful languages usually choose it as a baseline.
    Row types (Koka version~\cite{leijen2014koka, leijen2017type}) surprisingly fit the Hindley-Milner type inference style: sub-effecting is handled by adding additional polymorphic variables to effect rows $\{exn|\mu\}$.
    At the same time, rows should describe the whole needed computational context, leading to excessive verbosity of higher-order function types (consider \texttt{reyield} example above).


    \section{Systems based on capabilities} \label{sec:capabilities}

    Previously, we saw effects as calls of ``special'' functions, e.g., \texttt{print}, and listed all corresponding effect labels in types.
    This understanding leads us to quite verbose systems tracking too much information\footnote{We use underlining for highlighting purposes.}.
    \[\lambda x\ldotp \underline{print}\ap x\seq x + 1 : nat \to^{\{print\}} nat\]

    In this section, we will look at effects tracking from a different point of view.
    We assume that there are ``special'' objects in a program called capabilities.
    Effects can be performed only through them.
    Thus, the effect system should track the mention of such objects in the code.
    As we will see later, some systems track them by references (using reference-dependent types), and some track them by types of capabilities.
    For example, $console$ capability provides us with printing ability (we use syntax with dot to use a capability):
    \[\lambda x\ldotp \underline{console}.print\ap x\seq x + 1 : nat \to^{\{console\}} nat\]

    Functions can get capabilities by receiving them as arguments.
    So with capabilities, programmers can reason about effects the same way as they reason about bindings~\cite{brachthauser2022effects}, i.e., \ we can rewrite the example with an explicit parameter instead of effect type:
    \[\lambda \underline{console} \ap x \ldotp console.print\ap x\seq x + 1 : Console \to nat \to nat\]

    The explicit passing of capabilities as function arguments will be messy (which is precisely the problem we are trying to solve with effects).
    Therefore, language should provide some implicit parameter-passing support.
    In this perspective, we can see effect systems as a tool for tracking free, dynamically bound variables~\cite{odersky2022scoped}.
    This view complements the picture: the type system controls bounded variables, while the effect system tracks free ones.

    Capabilities offer a lightweight alternative to classical effect polymorphism called contextual effect polymorphism~\cite{brachthauser2022effects}.
    A capability is needed to perform an effect, but we can silently capture a capability in a lambda function and use it there.
    So we can write $map$ function with familiar type without any explicit presence of effect polymorphism (effect safety aspect we will discuss later):
    \[map = \Lambda a \ap b\ldotp \lambda f\ap xs\ldotp \ldots : \forall \ap a \ap b\ldotp \underline{(a \to b)} \to list \ap a \to list \ap b \]

    Another important aspect of capability-based effect systems is that they can be emulated in languages without built-in support using a specific programming style.
    More precisely, functions should not use global definitions to perform effects.
    Instead, they should receive capability objects as parameters (usually called services) and use method calls to perform effects on them.
    We demonstrate the idea using Scala with implicits feature~\cite{odersky2004scala}.
    The language is evolving to support exception checking case natively with \mintinline{scala}|CanThrow| magical capability~\cite{odersky2021safer}.
    \begin{minted}{scala}
        class FileError {
          def reportNotFound: Nothing =
            throw FileNotFoundException()
        }

        def process()(implicit fe: FileError) =
          fe.reportNotFound // use the capability

        // define scope for the capability
        def withFileError[R](f: FileError => R) =
          try {
            f(FileError())
          } catch case _: FileNotFoundException ...
    \end{minted}

    Unfortunately, capability-based effect systems require additional efforts to be safe, which complicates them significantly.
    Thus, the unsafe middle ground of the discussed programming style with some syntactic language support may seem like a satisfying compromise.

    A capability-based effect system is safe when it prevents capabilities from leaking out of dedicated scope.
    Exceptions are the most straightforward example: they should never be thrown outside the corresponding \mintinline{scala}|try-catch|.
    However, we can easily leak exception capability using the code above:
    \begin{minted}{scala}
        withFileError(error => error).reportNotFound
    \end{minted}

    We can obtain similar examples for other kinds of effects.
    For example, a mutable state can be allocated on the stack, and nobody should refer to it after the end of the corresponding function execution.
    The coroutine effect has a lightweight thread start point until delimited continuation is reified to be stored.
    The custom effect of persistent application storage uses a file handle, which can eventually be invalidated.
    Here, we can see similarities in concepts of resources and capabilities: both of them have limited lifetime, e.g., file handle is essentially a capability for working with a file.

    We need to distinguish between first-class values that can be passed around freely and second-class values with limited scope.
    One solution is to explicitly classify values on type level and restrict second-class values by the following rules~\cite{osvald2016gentrification}:
    \begin{enumerate}
        \item Capabilities are second-class;
        \item First-class functions cannot refer to second-class values through free variables;
        \item Functions can return only first-class values;
        \item Only first-class values can be stored in object fields or mutable variables.
    \end{enumerate}

    For example, file handle capability is a second-class value that cannot be returned.
    Also, the functional type is marked as second-class to be able to capture capabilities since it does not leak.
    We use extended Scala as proposed in~\cite{osvald2016gentrification}.
    The example will produce an error because inner lambda captures capabilities, so it is a second-class value, while outer lambda tries to return it, but returning second-class values is prohibited.
    \begin{minted}{scala}
        def withFile[R](
            f: @local (@local File) => R): R

        withFile(newFile => () => old.copyTo(newFile))
    \end{minted}

    This approach is quite inflexible.
    Imagine a curried map function that is popular for building data processing pipelines.
    There is no way to work with capabilities in this settings, since curried function will try to return a second class function, which is prohibited.
    Problems arise with inheritance as well, e.g., \ it is non-trivial to make a unified interface for lazy and eager collections~\cite{osvald2016gentrification}.

    Capabilities should not necessarily be explicit values.
    For instance, Effekt language\footnote{\url{https://effekt-lang.org/}} uses implicit passing of capabilities on the source level while being translated to calculus with explicit passing implementing lexically scoped effect handlers~\cite{brachthauser2020effects}.
    This approach requires effect handlers feature support and distances the effect system from direct control over resource use (which may be the point that resources should never be used directly, only via high-level domain-specific APIs).

    Effekt language uses row types as well.
    However, they have different semantics from those discussed in the previous section~\ref{sec:rows}.
    Namely, effect rows do not denote all effects of the context anymore.
    The semantics of such an effect system can be formulated as context readings of type signatures:
    \begin{minted}{scala}
        def buildString(ident: Int)
          // function block argument
          { f: () => () / {Yield[String]} }
          // capabilities ?\big\uparrow? buildString provides
          : String / {Format}
          // capabilities ?\big\uparrow? buildString requires
    \end{minted}

    Note that in this setting, effect encapsulation works by default.
    Effekt uses type-directed translation and will not provide capabilities to the argument block if it does not explicitly require them in type.
    So, this use case does not need masking at the term level.

    With implicit capabilities, we worry not about the leak of capability objects but delayed computations capturing capabilities.
    However, the effect system does not track all effects in a functional type, so it cannot check if the call site's context is valid.
    Effekt language solved this issue by making all functions second-class blocks~\cite{brachthauser2020effects}.

    Nevertheless, supporting only second-class blocks is too restrictive, as discussed before.
    There should be a way to explicate effects back in types to lift the second-class restriction.
    For this purpose, explicit boxing was proposed:
    \texttt{box} construct takes implicit capability requirements of a term and makes them explicit,
    \texttt{unbox} makes type system check that boxed value can be used in current computational context~\cite{hannan1998type, brachthauser2022effects}.
    So, second-class values can be boxed, leaked from the current context, carried to another context, and unboxed if this new context is appropriate.
    \begin{gather*}
        \infer[BoxIntro]{\Gamma \vdash \mathbf{box}\ap b : \sigma~ \mathbf{at}\ap C ~|~ \{\}}{\Gamma \vdash b : \sigma ~|~ C}
        \\
        \infer[BoxElim]{\Gamma \vdash \mathbf{unbox}\ap e : \sigma ~|~ C}{\Gamma \vdash e : \sigma ~\mathbf{at}~C ~|~ \{\}}
    \end{gather*}

    Since types of boxed values again list all effects, some form of effect polymorphism should be supported.
    Hence, Effekt features capability polymorphism, which expresses that a boxed value closes over the same capabilities captured by a particular value~\cite{brachthauser2022effects}.
    To do this, Effekt turned to explicit capability passing and tracking capability objects by references instead of by types.
    For example, now it is possible to write down a curried \texttt{map} function that returns a boxed block, capturing \texttt{f}, and, transitively, all capabilities captured by \texttt{f}.
    \begin{minted}{scala}
        def map[T, R] { f: T => R }
          : List<T> => R at {f}
          { box { xs => go(f, xs) } }

        map { x => console.print(x) }
          : List<T> => Unit at {console}
    \end{minted}

    Boxing provides some flexibility as well as new restrictions.
    Specifically, without explicit effect variables support, boxed values cannot be freely composed: one boxed value cannot be unboxed inside another since there is no way to describe that the second should inherit the first's capabilities.
    So, the boxed value should be unboxed before capturing; however, unboxing performs capability checks, which are unnecessary for reboxing.

    Much recent work in Scala language has investigated capture checking type systems that track for each value, which capabilities it captures~\cite{odersky2022scoped, boruch2023capturing}.
    The proposed approach is better integrated with subtyping and does not separate first- and second-class values.
    In the rest of the section, we will describe this approach.
    Experimental implementation is already available in Scala\footnote{\url{https://docs.scala-lang.org/scala3/reference/experimental/cc.html}}.

    We can ascribe every value of type \mintinline{scala}|T| with the type of the form \mintinline{scala}|T^{cap}| (or \mintinline{scala}|T^| for short), which indicates that this value is a capability and its use should be restricted.
    Namely, it cannot be returned from functions, and generics cannot be instantiated with its type.
    These values are like the second-class values described before, but the restriction of capability capturing is dropped: the type system accurately tracks capturing instead.
    For example, lazy list may capture \texttt{file} and \texttt{service} capabilities:
    \begin{minted}{scala}
        LazyList.fromFile(file)
                .map((line) => service.send(line))
          : LazyList[Int]^{file, service}
    \end{minted}

    Since contextual polymorphism is supported, functional types are capabilities as well.
    Specifically, \mintinline{scala}|=>| type is a syntactic sugar for \mintinline{scala}|->^{cap}| type (thin arrow is a type of pure functions).
    So, impure functions can capture capabilities and should obey capability restrictions.
    For example, \texttt{map} function (uncurried and curried versions) can be typed as follows:
    \begin{minted}{scala}
        def map[A,B](f: A => B, xs: List[A]): List[B]
        def map[A,B](f: A => B): List[A] ->^{f} List[B]
    \end{minted}

    Capabilities form subcapturing hierarchy: some capture sets can be safely used instead of others.
    $C_1 <: C_2$ if $C_1$ is covered by $C_2$.
    For instance, universal capability \mintinline{scala}|^{cap}| covers every other capability $C <: \{cap\}$; if some \mintinline{scala}|f| captures capabilities \mintinline{scala}|c1| and \mintinline{scala}|c2|, then $\{f\} <: \{c1, c2\}$ by transitivity.

    Let us consider a non-trivial example.
    We define \mintinline{scala}|Logger| class that depends on \mintinline{scala}|File| capability by receiving it in the primary constructor.
    \mintinline{scala}|test| function creates logger out of provided \mintinline{scala}|File|.
    \mintinline{scala}|map| on \mintinline{scala}|LazyList| returns a new list that remembers the provided lambda function, so this new list object captures the capabilities mentioned in the function's body.
    Note that types reflect all the capturing we describe.
    Finally, Scala checks that \mintinline{scala}|LazyList[Int]^{l}| is subtype of \mintinline{scala}|LazyList[Int]^{file}|.
    Indeed, it is true because one capture set covers another $\{l\} <: \{file\}$.
    \begin{minted}[escapeinside=##]{scala}
        class Logger(file: File^):
          def log(s: String): Unit = ???

        def test(file: File^): LazyList[Int]^{file} =
          val l: Logger^{file} = Logger(file)
          l.log("hello world!")
          val newList: LazyList[Int]^{l} =
            LazyList.from(1).map { i =>
              l.log(s"computing elem # $i")
              i * i
            }
          newList
    \end{minted}

    Note that the amount of syntactic pollution with the capture-checking approach seems quite reasonable.
    Users need to carry the syntactic burden only when leaking something out of scope; otherwise, capability inference should do the job.
    However, average programmers are generally not familiar with dependent types, which may complicate the adoption of this feature.

    In conclusion, capabilities offer a simple way of reasoning about effects as about special objects passed from outside.
    Context polymorphism allows to omit effect tracking ceremonies for simple cases.
    At the same time, establishing safety is non-trivial and requires class separation of values or dependent types.


    \section{Modal effect types} \label{sec:modal}

    TODO \cite{convent2020doo}\cite{tang2024modal}

    % todo Contextual Modal Type Theory Nanevski 2008

    % todo modal-based effect sytems


    \section{Conclusion}

    TODO % todo conclusion


%    \section*{Acknowledgment}
%
%    We thank Mikhail Belyaev, Denis Moskvin and Sergey Kovaltsov for the discussion and helpful comments.
%    Also, we are grateful to Huawei Corporation for funding this work.

    % todo acknoledgement


    \bibliographystyle{ieeetran}
    \bibliography{bib}

\end{document}
